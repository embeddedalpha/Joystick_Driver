.TH "CMSIS_Core_InstructionInterface" 3 "Version JSTDRVF4" "Joystick Driver" \" -*- nroff -*-
.ad l
.nh
.SH NAME
CMSIS_Core_InstructionInterface \- CMSIS Core Instruction Interface
.SH SYNOPSIS
.br
.PP
.SS "Topics"

.in +1c
.ti -1c
.RI "\fBCMSIS Core Register Access Functions\fP"
.br
.in -1c
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fB__NOP\fP   __nop"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP   __wfi"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP   __wfe"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP   __sev"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__ISB\fP()"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DSB\fP()"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DMB\fP()"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "#define \fB__REV\fP   __rev"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "#define \fB__ROR\fP   __ror"
.br
.RI "Rotate Right in unsigned value (32 bit) "
.ti -1c
.RI "#define \fB__BKPT\fP(value)"
.br
.RI "Breakpoint\&. "
.ti -1c
.RI "#define \fB__CLZ\fP   __clz"
.br
.RI "Count leading zeros\&. "
.ti -1c
.RI "#define \fB__CMSIS_GCC_OUT_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_RW_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_USE_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__NOP\fP   __builtin_arm_nop"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP   __builtin_arm_wfi"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP   __builtin_arm_wfe"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP   __builtin_arm_sev"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__ISB\fP()"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DSB\fP()"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DMB\fP()"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "#define \fB__REV\fP(value)"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "#define \fB__REV16\fP(value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "#define \fB__REVSH\fP(value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "#define \fB__BKPT\fP(value)"
.br
.RI "Breakpoint\&. "
.ti -1c
.RI "#define \fB__RBIT\fP   __builtin_arm_rbit"
.br
.RI "Reverse bit order of value\&. "
.ti -1c
.RI "#define \fB__CMSIS_GCC_OUT_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_USE_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__NOP\fP   __builtin_arm_nop"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP   __builtin_arm_wfi"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP   __builtin_arm_wfe"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP   __builtin_arm_sev"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__ISB\fP()"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DSB\fP()"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "#define \fB__DMB\fP()"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "#define \fB__REV\fP(value)"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "#define \fB__REV16\fP(value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "#define \fB__REVSH\fP(value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "#define \fB__BKPT\fP(value)"
.br
.RI "Breakpoint\&. "
.ti -1c
.RI "#define \fB__RBIT\fP   __builtin_arm_rbit"
.br
.RI "Reverse bit order of value\&. "
.ti -1c
.RI "#define \fB__CMSIS_GCC_OUT_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_RW_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__CMSIS_GCC_USE_REG\fP(r)"
.br
.ti -1c
.RI "#define \fB__NOP\fP()"
.br
.RI "No Operation\&. "
.ti -1c
.RI "#define \fB__WFI\fP()"
.br
.RI "Wait For Interrupt\&. "
.ti -1c
.RI "#define \fB__WFE\fP()"
.br
.RI "Wait For Event\&. "
.ti -1c
.RI "#define \fB__SEV\fP()"
.br
.RI "Send Event\&. "
.ti -1c
.RI "#define \fB__BKPT\fP(value)"
.br
.RI "Breakpoint\&. "
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "\fB__attribute__\fP ((section('\&.rev16_text'))) __STATIC_INLINE __ASM uint32_t \fB__REV16\fP(uint32_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "\fB__attribute__\fP ((section('\&.revsh_text'))) __STATIC_INLINE __ASM int16_t \fB__REVSH\fP(int16_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "\fB__attribute__\fP ((always_inline)) __STATIC_INLINE uint32_t \fB__RBIT\fP(uint32_t value)"
.br
.RI "Reverse bit order of value\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE uint32_t \fB__ROR\fP (uint32_t op1, uint32_t op2)"
.br
.RI "Rotate Right in unsigned value (32 bit) "
.ti -1c
.RI "__STATIC_FORCEINLINE uint8_t \fB__CLZ\fP (uint32_t value)"
.br
.RI "Count leading zeros\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE int32_t \fB__SSAT\fP (int32_t val, uint32_t sat)"
.br
.RI "Signed Saturate\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE uint32_t \fB__USAT\fP (int32_t val, uint32_t sat)"
.br
.RI "Unsigned Saturate\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE void \fB__ISB\fP (void)"
.br
.RI "Instruction Synchronization Barrier\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE void \fB__DSB\fP (void)"
.br
.RI "Data Synchronization Barrier\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE void \fB__DMB\fP (void)"
.br
.RI "Data Memory Barrier\&. "
.ti -1c
.RI "__STATIC_FORCEINLINE uint32_t \fB__REV\fP (uint32_t value)"
.br
.RI "Reverse byte order (32 bit) "
.ti -1c
.RI "__STATIC_FORCEINLINE uint32_t \fB__REV16\fP (uint32_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "__STATIC_FORCEINLINE int16_t \fB__REVSH\fP (int16_t value)"
.br
.RI "Reverse byte order (16 bit) "
.ti -1c
.RI "__STATIC_FORCEINLINE uint32_t \fB__RBIT\fP (uint32_t value)"
.br
.RI "Reverse bit order of value\&. "
.in -1c
.SS "Variables"

.in +1c
.ti -1c
.RI "uint32_t \fBsat\fP"
.br
.in -1c
.SH "Detailed Description"
.PP 
Access to dedicated instructions

.PP
Access to dedicated instructions

.PP
Access to dedicated instructions

.PP
Access to dedicated instructions 
.SH "Macro Definition Documentation"
.PP 
.SS "#define __BKPT( value)"
\fBValue:\fP
.nf
__breakpoint(value)
.PP
.fi

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.PP
Definition at line \fB248\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __BKPT( value)"
\fBValue:\fP
.nf
__ASM volatile ("bkpt "#value)
.PP
.fi

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.PP
Definition at line \fB278\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __BKPT( value)"
\fBValue:\fP
.nf
__ASM volatile ("bkpt "#value)
.PP
.fi

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.PP
Definition at line \fB276\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __BKPT( value)"
\fBValue:\fP
.nf
__ASM volatile ("bkpt "#value)
.PP
.fi

.PP
Breakpoint\&. Causes the processor to enter Debug state\&. Debug tools can use this to investigate system state when the instruction at a particular address is reached\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP is ignored by the processor\&. If required, a debugger can use it to store additional information about the breakpoint\&. 
.RE
.PP

.PP
Definition at line \fB364\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __CLZ   __clz"

.PP
Count leading zeros\&. Counts the number of leading zeros of a data value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to count the leading zeros 
.RE
.PP
\fBReturns\fP
.RS 4
number of leading zeros in value 
.RE
.PP

.PP
Definition at line \fB285\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __CMSIS_GCC_OUT_REG( r)"
\fBValue:\fP
.nf
"=r" (r)
.PP
.fi

.PP
Definition at line \fB169\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __CMSIS_GCC_OUT_REG( r)"
\fBValue:\fP
.nf
"=r" (r)
.PP
.fi

.PP
Definition at line \fB168\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __CMSIS_GCC_OUT_REG( r)"
\fBValue:\fP
.nf
"=r" (r)
.PP
.fi

.PP
Definition at line \fB219\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __CMSIS_GCC_RW_REG( r)"
\fBValue:\fP
.nf
"+r" (r)
.PP
.fi

.PP
Definition at line \fB170\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __CMSIS_GCC_RW_REG( r)"
\fBValue:\fP
.nf
"+r" (r)
.PP
.fi

.PP
Definition at line \fB220\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __CMSIS_GCC_USE_REG( r)"
\fBValue:\fP
.nf
"r" (r)
.PP
.fi

.PP
Definition at line \fB171\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __CMSIS_GCC_USE_REG( r)"
\fBValue:\fP
.nf
"r" (r)
.PP
.fi

.PP
Definition at line \fB169\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __CMSIS_GCC_USE_REG( r)"
\fBValue:\fP
.nf
"r" (r)
.PP
.fi

.PP
Definition at line \fB221\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __DMB( void)"
\fBValue:\fP
.nf
__dmb(0xF)
.PP
.fi

.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.PP
Definition at line \fB189\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __DMB( void)"
\fBValue:\fP
.nf
__builtin_arm_dmb(0xF)
.PP
.fi

.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.PP
Definition at line \fB223\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __DMB( void)"
\fBValue:\fP
.nf
__builtin_arm_dmb(0xF)
.PP
.fi

.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.PP
Definition at line \fB221\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __DSB( void)"
\fBValue:\fP
.nf
__dsb(0xF)
.PP
.fi

.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.PP
Definition at line \fB182\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __DSB( void)"
\fBValue:\fP
.nf
__builtin_arm_dsb(0xF)
.PP
.fi

.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.PP
Definition at line \fB215\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __DSB( void)"
\fBValue:\fP
.nf
__builtin_arm_dsb(0xF)
.PP
.fi

.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.PP
Definition at line \fB213\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __ISB( void)"
\fBValue:\fP
.nf
__isb(0xF)
.PP
.fi

.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.PP
Definition at line \fB175\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __ISB( void)"
\fBValue:\fP
.nf
__builtin_arm_isb(0xF)
.PP
.fi

.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.PP
Definition at line \fB208\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __ISB( void)"
\fBValue:\fP
.nf
__builtin_arm_isb(0xF)
.PP
.fi

.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.PP
Definition at line \fB206\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __NOP   __nop"

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.PP
Definition at line \fB144\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __NOP   __builtin_arm_nop"

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.PP
Definition at line \fB178\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __NOP   __builtin_arm_nop"

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.PP
Definition at line \fB176\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __NOP()"
\fBValue:\fP
.nf
__ASM volatile ("nop")
.PP
.fi

.PP
No Operation\&. No Operation does nothing\&. This instruction can be used for code alignment purposes\&. 
.PP
Definition at line \fB228\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __RBIT   __builtin_arm_rbit"

.PP
Reverse bit order of value\&. Reverses the bit order of the given value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB287\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __RBIT   __builtin_arm_rbit"

.PP
Reverse bit order of value\&. Reverses the bit order of the given value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB285\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __REV   __rev"

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB198\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __REV( value)"
\fBValue:\fP
.nf
__builtin_bswap32(value)
.PP
.fi

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB232\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __REV( value)"
\fBValue:\fP
.nf
__builtin_bswap32(value)
.PP
.fi

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB230\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __REV16( value)"
\fBValue:\fP
.nf
__ROR(__REV(value), 16)
.PP
.fi

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB241\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __REV16( value)"
\fBValue:\fP
.nf
__ROR(__REV(value), 16)
.PP
.fi

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB239\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __REVSH( value)"
\fBValue:\fP
.nf
(int16_t)__builtin_bswap16(value)
.PP
.fi

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB250\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __REVSH( value)"
\fBValue:\fP
.nf
(int16_t)__builtin_bswap16(value)
.PP
.fi

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB248\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __ROR   __ror"

.PP
Rotate Right in unsigned value (32 bit) Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits\&. 
.PP
\fBParameters\fP
.RS 4
\fIop1\fP Value to rotate 
.br
\fIop2\fP Number of Bits to rotate 
.RE
.PP
\fBReturns\fP
.RS 4
Rotated value 
.RE
.PP

.PP
Definition at line \fB238\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __SEV   __sev"

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.PP
Definition at line \fB166\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __SEV   __builtin_arm_sev"

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.PP
Definition at line \fB199\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __SEV   __builtin_arm_sev"

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.PP
Definition at line \fB197\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __SEV()"
\fBValue:\fP
.nf
__ASM volatile ("sev")
.PP
.fi

.PP
Send Event\&. Send Event is a hint instruction\&. It causes an event to be signaled to the CPU\&. 
.PP
Definition at line \fB249\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __WFE   __wfe"

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.PP
Definition at line \fB159\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __WFE   __builtin_arm_wfe"

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.PP
Definition at line \fB192\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __WFE   __builtin_arm_wfe"

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.PP
Definition at line \fB190\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __WFE()"
\fBValue:\fP
.nf
__ASM volatile ("wfe":::"memory")
.PP
.fi

.PP
Wait For Event\&. Wait For Event is a hint instruction that permits the processor to enter a low-power state until one of a number of events occurs\&. 
.PP
Definition at line \fB242\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "#define __WFI   __wfi"

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.PP
Definition at line \fB151\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "#define __WFI   __builtin_arm_wfi"

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.PP
Definition at line \fB184\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "#define __WFI   __builtin_arm_wfi"

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.PP
Definition at line \fB182\fP of file \fBcmsis_armclang_ltm\&.h\fP\&.
.SS "#define __WFI()"
\fBValue:\fP
.nf
__ASM volatile ("wfi":::"memory")
.PP
.fi

.PP
Wait For Interrupt\&. Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs\&. 
.PP
Definition at line \fB234\fP of file \fBcmsis_gcc\&.h\fP\&.
.SH "Function Documentation"
.PP 
.SS "__attribute__ ((always_inline) )"

.PP
Reverse bit order of value\&. Unsigned Saturate\&.

.PP
Signed Saturate\&.

.PP
Reverses the bit order of the given value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value
.RE
.PP
Saturates a signed value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (1\&.\&.32) 
.RE
.PP
\fBReturns\fP
.RS 4
Saturated value
.RE
.PP
Saturates an unsigned value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (0\&.\&.31) 
.RE
.PP
\fBReturns\fP
.RS 4
Saturated value 
.RE
.PP

.PP
Definition at line \fB261\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "__attribute__ ((section('\&.rev16_text')) )"

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB208\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "__attribute__ ((section('\&.revsh_text')) )"

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB223\fP of file \fBcmsis_armcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE uint8_t __CLZ (uint32_t value)"

.PP
Count leading zeros\&. Counts the number of leading zeros of a data value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to count the leading zeros 
.RE
.PP
\fBReturns\fP
.RS 4
number of leading zeros in value 
.RE
.PP

.PP
Definition at line \fB295\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "__STATIC_FORCEINLINE void __DMB (void )"

.PP
Data Memory Barrier\&. Ensures the apparent order of the explicit memory operations before and after the instruction, without ensuring their completion\&. 
.PP
Definition at line \fB280\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE void __DSB (void )"

.PP
Data Synchronization Barrier\&. Acts as a special kind of Data Memory Barrier\&. It completes when all explicit memory accesses before this instruction complete\&. 
.PP
Definition at line \fB269\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE void __ISB (void )"

.PP
Instruction Synchronization Barrier\&. Instruction Synchronization Barrier flushes the pipeline in the processor, so that all instructions following the ISB are fetched from cache or memory, after the instruction has been completed\&. 
.PP
Definition at line \fB258\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE uint32_t __RBIT (uint32_t value)"

.PP
Reverse bit order of value\&. Reverses the bit order of the given value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB373\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE uint32_t __REV (uint32_t value)"

.PP
Reverse byte order (32 bit) Reverses the byte order in unsigned integer value\&. For example, 0x12345678 becomes 0x78563412\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB292\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE uint32_t __REV16 (uint32_t value)"

.PP
Reverse byte order (16 bit) Reverses the byte order within each halfword of a word\&. For example, 0x12345678 becomes 0x34127856\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB311\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE int16_t __REVSH (int16_t value)"

.PP
Reverse byte order (16 bit) Reverses the byte order in a 16-bit value and returns the signed 16-bit result\&. For example, 0x0080 becomes 0x8000\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to reverse 
.RE
.PP
\fBReturns\fP
.RS 4
Reversed value 
.RE
.PP

.PP
Definition at line \fB326\fP of file \fBcmsis_gcc\&.h\fP\&.
.SS "__STATIC_FORCEINLINE uint32_t __ROR (uint32_t op1, uint32_t op2)"

.PP
Rotate Right in unsigned value (32 bit) Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits\&. 
.PP
\fBParameters\fP
.RS 4
\fIop1\fP Value to rotate 
.br
\fIop2\fP Number of Bits to rotate 
.RE
.PP
\fBReturns\fP
.RS 4
Rotated value 
.RE
.PP

.PP
Definition at line \fB260\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "__STATIC_FORCEINLINE int32_t __SSAT (int32_t val, uint32_t sat)"

.PP
Signed Saturate\&. Saturates a signed value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (1\&.\&.32) 
.RE
.PP
\fBReturns\fP
.RS 4
Saturated value 
.RE
.PP

.PP
Definition at line \fB526\fP of file \fBcmsis_armclang\&.h\fP\&.
.SS "__STATIC_FORCEINLINE uint32_t __USAT (int32_t val, uint32_t sat)"

.PP
Unsigned Saturate\&. Saturates an unsigned value\&. 
.PP
\fBParameters\fP
.RS 4
\fIvalue\fP Value to be saturated 
.br
\fIsat\fP Bit position to saturate to (0\&.\&.31) 
.RE
.PP
\fBReturns\fP
.RS 4
Saturated value 
.RE
.PP

.PP
Definition at line \fB551\fP of file \fBcmsis_armclang\&.h\fP\&.
.SH "Variable Documentation"
.PP 
.SS "uint32_t sat"
\fBInitial value:\fP
.nf
{
  if ((sat >= 1U) && (sat <= 32U))
  {
    const int32_t max = (int32_t)((1U << (sat \- 1U)) \- 1U);
    const int32_t min = \-1 \- max ;
    if (val > max)
    {
      return max;
    }
    else if (val < min)
    {
      return min;
    }
  }
  return val
.PP
.fi

.PP
Definition at line \fB481\fP of file \fBcmsis_armcc\&.h\fP\&.
.SH "Author"
.PP 
Generated automatically by Doxygen for Joystick Driver from the source code\&.
